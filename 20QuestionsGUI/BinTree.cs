/* BinDecTree class - Handles the decision tree.
 * root attribute is a pointer to the root node of the tree and can be set by calling
 * either Hardwire() or ReadTree().  Since ReadTree() is the hardest method to write,
 * students should use Hardware to set up the tree for all the other functionality
 * before they attempt ReadTree().
 * ReadTree() constructs the decision tree by reading a text file that represents
 * a pre-order traversal of the desired decision tree.  The assumption is that the data
 * file was generated by a call to a correct WriteTree() method, meaning that the traversal
 * should never get lost in a badly formatted file.
 * 
 * 
 * editor: Zach Brown
 * date: 3/18/2018
 * assignment: 20 Questions Game
 * professor: Eric Baker
 * course: IGME 201
 */

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace _20QuestionsGUI
{
    public class BinTree
    {
        public Node Root = null;

        //option way 2
        //const string k_SAVE_FILE_PATH = "savedTree.txt";


        //  Used to build the tree before ReadTree method is built.
        public void HardCode()
        {
            //  Branch  - living
            Root = new Node("living");
            //  Leaf    - Bill Gates
            Root.Left = new Node("Bill Gates");
            //  Leaf    - Chester Carlson
            Root.Right = new Node("Chester Carlson");
        }

        //part 4: reading the tree with lists
        public void ReadTree()
        {
            //Stream
            StreamReader stream = new StreamReader("BinTree.txt");

            //option way 2
            //FileStream stream = new FileStream(k_SAVE_FILE_PATH, FileMode.Create);
            //StreamWriter streamWriter = new StreamWriter(stream);

            Root = new Node("");
            Root.Left = Traverse(stream);
            stream.Close();
            /*    for(int i = 0; i < nodes.Length; i++)
                {
                    char NodeType = nodes[i][0];
                    if(NodeType == 'I')
                    {
                        nodes[i] = nodes[i].TrimStart('I');
                        Root.Left = new Node(nodes[i]);
                    }
                    else
                    {
                        nodes[i] = nodes[i].TrimStart('L');
                    }
                } */
        }

        //node method to read each line put into input, traverse and move down whether it's a L or I property
        public Node Traverse(StreamReader reader)
        {
            string node = reader.ReadLine();
            if (node != null)
            {
                char nodeType = node[0];
                node = node.TrimStart(nodeType);
                Node n = new Node(node);
                if (nodeType == 'I')
                {
                    n.Left = Traverse(reader);
                    n.Right = Traverse(reader);
                }
                else
                {
                    n.Left = null;
                    n.Right = null;
                }
                return n;
            }
            return null;
        }

        //part 3: method to write the current tree into a JSON file
        public void WriteTree()
        {
            Traverse();
        }

        //  Used for debugging to send the traversal to the screen. Sets up and calls recursive method
        public void Traverse()
        {
            File.Delete("BinTree.txt");

            if (Root != null)
            {
                RecTraverse(Root.Left);
            }
        }

        //  Recursive method to do the actual pre-order traversal
        void RecTraverse(Node n)
        {
            if (n.Left == null)
            {
                File.AppendAllLines("BinTree.txt", new string[] { "L" + n.data });
                Console.WriteLine("B-{0}", n.data); //Leaf Node
            }
            else
            {
                Console.WriteLine("B-{0}", n.data);  // Branch Node 
                File.AppendAllLines("BinTree.txt", new string[] { "I" + n.data });
                RecTraverse(n.Left);

                RecTraverse(n.Right);
            }
        }
    }
}
